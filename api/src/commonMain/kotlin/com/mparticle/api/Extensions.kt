package com.mparticle.api

import kotlin.native.concurrent.SharedImmutable
import kotlin.reflect.KCallable
import kotlin.reflect.KMutableProperty0
import kotlin.reflect.KProperty

val mParticle
    get() = MParticle.getInstance() ?: throw RuntimeException("MParticle has not been started!")

enum class Platform {
    Android,
    iOS
}

/**
 * The iOS wrapper generated by mutiplatform has a weird quirk in it where, for every property, it
 * will also generate a setter and getter method with the same name. for example, Class Foo might look
 * like:
 *
 * class Foo {
 *      var bar: String
 *      fun bar(): String
 *      fun setBar(bar: String)
 * }
 *
 * This makes it impossible to use the `bar` or `bar()` as a delegate, since there is ambiguity
 * when referencing it.
 *
 * for example if you wanted to use Foo.bar to delegate Fuzz.baz, as such:
 *
 * class Fuzz(foo: Foo) {
 *      var baz: String by foo::bar
 * }
 *
 * it will fail as ambiguous.
 *
 * This helper function will indicate to the compiler that you are referencing the *property* `foo`.
 * Using this method, you get the above to work by:
 *
 * class Fuzz(foo: Foo) {
 *      var baz: String by property(foo::bar)
 * }
 */
fun <T> property(property: KMutableProperty0<T>): KMutableProperty0<T> = property
fun <T> nullableProperty(property: KMutableProperty0<T>) =
    TransformDelegate(
        property,
        TransformBuilder
        .from<T?, T> { this!! }
        .to { this as T? }
    )

/**
 * helper used for delegating to a "transformable" type. This can be used when we have a Kotlin field
 * of type String that we want to delegate to a generated iOS field that has type NSString. Assuming
 * we have the mapping methods, we can use it as such:
 *
 * //iOS generated class
 * class Foo {
 *      var bar: NSString
 * }
 *
 * //delegated kotlin class
 * class Fuzz(foo: Foo) {
 *      fun String.toNSString(): NSString
 *      fun NSString.toKString(): String
 *
 *      var baz: String by TransformDelegate(foo::bar, { toNSString() }, { toKString() }
 * }
 *
 */
class TransformDelegate<Kotlin, Native>(private val property: KMutableProperty0<Native>, private val transformer: Transformer<Kotlin, Native>) {
    operator fun getValue(ref: Any?, kProp: KProperty<*>): Kotlin {
        return property.getValue(ref, kProp).let { transformer.to(it) }
    }

    operator fun setValue(ref: Any?, kProp: KProperty<*>, value: Kotlin) {
        transformer.from(value).let {
            property.setValue(ref, kProp, it)
        }
    }
}

interface Transformer<Kotlin, Native> {
    fun from(target: Kotlin): Native
    fun to(target: Native): Kotlin
}

object TransformBuilder {
    fun <Kotlin, Native> from(fromFunction: Kotlin.() -> Native): TransformFrom<Kotlin, Native> = fromFunction
}

//typealias TransformFrom<T, R> = R.() -> T
typealias TransformFrom<Kotlin, Native> = Kotlin.() -> Native
fun <Kotlin, Native> TransformFrom<Kotlin, Native>.to(toFunction: Native.() -> Kotlin): Transformer<Kotlin, Native> =
    object: Transformer<Kotlin, Native> {
        override fun from(target: Kotlin): Native = this@to.invoke(target)
        override fun to(target: Native): Kotlin = target.toFunction()
    }

//EXAMPLE
private val stringIntTransformer: Transformer<String, Int> = TransformBuilder
    .from<String, Int> { this.toInt() }
    .to {this.toString()}


/**
 * For "one way" delegation. i.e we have a `var` property in this API but we want to bind with an write-only
 * field in a delegate
 */
internal open class GenericDelegate<Native, Kotlin>(val default: Kotlin, private val setter: Native.(Kotlin) -> Unit) {
    val map = mutableMapOf<Native, Kotlin>();
    internal inline operator fun getValue(instance: Native, field: KCallable<*>): Kotlin {
        return map.get(instance) ?: default
    }

    internal inline operator fun setValue(instance: Native, field: KCallable<*>, value: Kotlin) {
        map[instance] = value
        instance.setter(value)
    }
}

internal class DoubleDelegate<C>(setter: C.(Double) -> Unit): GenericDelegate<C, Double>(0.0, setter)

internal class StringDelegate<C>(setter: C.(String) -> Unit): GenericDelegate<C, String>("", setter)

internal class IntDelegate<C>(setter: C.(Int) -> Unit): GenericDelegate<C, Int>(0, setter)

internal class BooleanDelegate<C>(setter: C.(Boolean) -> Unit): GenericDelegate<C, Boolean>(false, setter)

internal class NullableDelegate<Default, Kotlin: Any?>(setter: Default.(Kotlin) -> Unit): GenericDelegate<Default, Kotlin>(null as Kotlin, setter)
